from pydantic import BaseModel, Field
from enum import Enum
from typing import Optional, List
from datetime import datetime

# ===================
# Enums
# ===================

class Sentiment(str, Enum):
    POSITIVE = "positive"
    NEUTRAL = "neutral"
    NEGATIVE = "negative"

class ResolutionStatus(str, Enum):
    RESOLVED = "resolved"
    UNRESOLVED = "unresolved"
    ESCALATED = "escalated"

class AbuseType(str, Enum):
    PROFANITY = "profanity"
    THREAT = "threat"
    HARASSMENT = "harassment"
    DISCRIMINATION = "discrimination"
    NONE = "none"

class AbuseSeverity(str, Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"
    NONE = "none"

# ===================
# Data Models
# ===================

class CallMetadata(BaseModel):
    """Metadata extracted by Intake Agent"""
    call_id: str
    timestamp: datetime = Field(default_factory=datetime.now)
    duration_seconds: Optional[float] = None
    input_type: str  # "audio" | "transcript"
    file_name: Optional[str] = None

class TranscriptSegment(BaseModel):
    """Single segment of a transcript"""
    speaker: str
    text: str
    start_time: Optional[float] = None
    end_time: Optional[float] = None

class TranscriptData(BaseModel):
    """Full transcript data"""
    segments: List[TranscriptSegment] = []
    full_text: str
    language: str = "en"
    confidence: float = Field(default=1.0, ge=0.0, le=1.0)

class CallSummary(BaseModel):
    """Summary generated by Summarization Agent"""
    brief_summary: str = Field(description="2-3 sentence overview")
    key_points: List[str] = Field(description="3-5 bullet points")
    action_items: List[str] = Field(default=[], description="Follow-up tasks")
    customer_intent: str = Field(description="What the customer wanted")
    resolution_status: ResolutionStatus
    topics: List[str] = Field(description="Main topics discussed")
    sentiment: Sentiment

class QAScores(BaseModel):
    """Quality scores from QA Scoring Agent"""
    empathy: float = Field(ge=0, le=10)
    professionalism: float = Field(ge=0, le=10)
    resolution: float = Field(ge=0, le=10)
    tone: float = Field(ge=0, le=10)
    comments: str = ""

    @property
    def overall(self) -> float:
        return round((self.empathy + self.professionalism + self.resolution + self.tone) / 4, 1)

class SummaryCritique(BaseModel):
    """Critique from Summary Critic Agent"""
    faithfulness_score: int = Field(ge=1, le=10)
    completeness_score: int = Field(ge=1, le=10)
    conciseness_score: int = Field(ge=1, le=10)
    needs_revision: bool
    revision_instructions: Optional[str] = None
    feedback: str

class AbuseFlag(BaseModel):
    """Abuse detection result"""
    detected: bool = False
    speaker: Optional[str] = None  # "customer" | "agent" | "both"
    abuse_type: List[AbuseType] = [AbuseType.NONE]
    severity: AbuseSeverity = AbuseSeverity.NONE
    evidence: List[str] = []
    recommended_action: str = ""
    requires_escalation: bool = False

class InputValidationResult(BaseModel):
    """Result from input validation guardrail"""
    is_valid: bool
    confidence: float = Field(ge=0.0, le=1.0)
    input_type_detected: str
    issues: List[str] = []
    warnings: List[str] = []
    requires_user_confirmation: bool = False
    rejection_reason: Optional[str] = None

# ===================
# Agent State
# ===================

class AgentState(BaseModel):
    """State passed between agents in LangGraph"""

    # Input
    input_file_path: Optional[str] = None
    input_type: str = "transcript"  # "audio" | "transcript"
    raw_input: Optional[str] = None
    audio_data: Optional[bytes] = None  # Raw audio bytes for Whisper API

    # Validation
    validation_result: Optional[InputValidationResult] = None
    user_confirmed: bool = False

    # Processing outputs
    metadata: Optional[CallMetadata] = None
    transcript: Optional[TranscriptData] = None
    summary: Optional[CallSummary] = None
    summary_critique: Optional[SummaryCritique] = None
    qa_scores: Optional[QAScores] = None
    abuse_flags: List[AbuseFlag] = []

    # Control flow
    current_agent: str = "supervisor"
    needs_revision: bool = False
    revision_count: int = 0
    execution_path: List[str] = []
    models_used: List[str] = []
    errors: List[str] = []

    class Config:
        arbitrary_types_allowed = True
